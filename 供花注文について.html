<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>供花について</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">供花について</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af8fe844c0eeb411af8f5be4b7e962a31c5f6733d133d5b76ebc5c5574882ef3964d9035a2957bd3119360233eeda16693977723520522593cafe652eb9d2e76798b5d8b21545c61c731084168e83c8b16973a664c0c4a932ca60e395a8657443fd07c365053abe773a6760a415bbae11745d91143b9b59a6b508f3daf40885f0038416f7f5eaebe9d3c944f7f88d584b6c90af79f39090db8c9577a23c51b0f9360ae36acc91b32aea9cf371a8544bed508fe56e922cfb0337a6eb2a71b282945bfe9532cf82e3cb58deb4b123b810d8fcfd33534cd1fc47d77a2a756328624182f53ae4ae0f3c6c56ebc4281431b83558094695497855060fe052949fd1f1c3923624b91dcd7e8f4f588cc75466b442cc79c04a1c8cbef393f0bdef37a308420f64e17179b6ca9b08e635ae22c4c4a7a78b7c74581a2b074d3104ef162976bcbd7fda2052d7f185880eb81cb43919706d7d167c7b2727e5261a25ac8d6522bea7726beea1b6345b9505fc5475cb93649726ff2aca6979afaa5a43f5209a49fd1d803257bb34bf39664a5ae20c8dff67932f76d2ce5bab14de2157fef55cecd8b5da612dd9bd792d49a8fc92ad0d392823dc6c2468473071c2ebac5a94014b9780e251e386e4a140199106e8e115d7259efe387e42490bd5c4412a14e3d0c4fe6ff042c1d667303b5b95036115a49b00e9a9803f462788b724b6c4afa46b9b5096739f4fcf0d6e915007409aa19f566a834ce60a04eb35a867c240b527274f4a9ea2bd6440e55bfe98305b2433d11e19bdba9b0401b23221ebbb8823c52afb19cd5e471ce0cb532e02a204629e4e79b086dc3e40619188c66a94ec9059ce0052d50189c4bb1ecba48132656177df30100434cd4797ed8f87fd85c3de0154ff7bd1acb190f6fc6c6c70df12fb7064ec85d77ad0f814c0775ca850da5c463afe7af0d31e1c0099e946271048e7facac1cc862df4494917c000516ab5d6d55d8e0ccdbb1ea0a68228096164c0f77d7b21330dd632e7901b54aca1424ddf8e424f1e83d557a5783704d5c801c82123bdab04f49fe94781af32d84347ad464ae2ffb72359bd2686b516cdbb2ae2bf75c98f723f6aa88025f6e9da9a3317105b5e5a05073f47b4bdbfe684f66043b7117e448771e38928300ae53977c73cd5e0643d15636d825cf57ae86e280a091a590d30d415cae7a77ab61245df3b710772e478b055d26cda6f1e0553a6925f9c59e56f5cb9cbed44a16da386782914478020334dda8e9ed72ec1933b7dfb58b8b21640b8a8e01cf94d2f074f156dc7138377a2c521c9d025ada67d525fea1f5a85a90ab2f313611575d492d528ab21dacb3f35be439d2bc6b4d35e9edf201c4961df98c04c0c36d8ee13a608957d2967d20eab02d622964bba65ea986a6d4a6e621195f767cc06b3d20d44a46788d3a84208706f75d46929e382e4da795ff4769170fc0aef711441a81cc2fe51c2afba0e834160998689a43223cbd1b32283f54a9c3da8b8daf2a57de8a734403655d456cc8e1d1c7baa5afe4b99191a071a47dfdd951fbf836ade060733159f33e83b2902d4be38609643c20d72f58cb9020fbe208f91e79b6c12600cd363d474b13654538144b8c22bcded4c5add04775a3ade4d565a6432ad66fd143299e1a6e636bad4f7e9c31caaf8265725a34ed00ca258c0c56250d5d2a7886bdd224ea2a4c12d31c00e9707fbe6e5b86d481e7f4bbaa2e691639a7117e72c5219ff5e728238b99e527a01de3e1ee38b0593e02a81a672e2d19a1170c0bf9ef2006b2e803bb2f1d7058039871ccd25d951e4bd6ac4ca5a7ba1f9056b555b2786d7b24571c2244f658324c69d7f3294409747a04057f30d450f4f717309285f3e41cfcc4891fe03e34531a718f920d4646d50fcb5f3fe0b0273b5c512294d7af35ba2524ac1fdfc447b0d9baa4ea13b73505421fe21de50f2b025ae337b900916acc84bb600e81186e53fc401f62d4dd4a78a42c1526cab1a30f2d4e8fe96c5ba962d8cc28d868806b4d76cb1ee602dbe881979a3e25f5b1fab2144ce2ed3a0fec8366441bab545da4c6a023d009b1b9e9b67380be4970a0468c1bc5aad124ced946cb8f6785883f4f81d88745d220b5b2278fa2b50cacae6d2b51045a34a8c2e12ee921a75c4381dde30d7f22e1136e20874effbb0ba9a92fff462ef659dcc13eb0cf7d71f49e923c84c4e2c1c7ae28e7277f6a1c5e82ea63f0499ba6669be640861506d376226136df5b407e7d40a16981a457642864a0210f2d36581e3198687641cf382e008205a0be8111c85f761d215b83fa3dcc6c96bd67b34a1ccc1725b675f0f20fe7380d2c952c4492fd061fb3eea48abd7171ee451dff27ee725b3f490e745562045732bb25b23a78d1b2a8f2d55c5a87dde92f328ed4cd37c61bd23c97b3c02a96f8ee07f05a83e3a6fdb9fd900c28df5b57bd34b1a13a639baa9048ecad2e3bdf35ea88c771d8a1037cf10541e22d68c5a5fd95a1d0682b6c91c80868a6e3bcaa4f1522fa8cae5070b1f671e62f6e9d8112104a30fcdec5fcc079c55fba57f29ee5a0ac32c22c805ef8bbac908f1d5f14d1c599733199b050211a23dce5aa26be835699721838085ed090bf981e94f2a120b96e48235b265b3eca9cdd8c0420b60534866d7bbda1b4a283d2e6afab00406d370a0ab2ce221bf84911af1010d9ec03547e28b2a2294e04a35704853ec54ba5d1c357e3ad405238278302eda07a2233ac14f652a54d13203ecbbb2f460f4c718ba5699040fed5d20d624b511c95a5c83b619c36604d0221db21074bae1e85944356bbd9a07fa9cc920ae9b6361e33d66c642d9b9754610ee1d2ee9d871038b36f1a031c79c348335fae276d4f01557a24851272193fd66ab2399fa1300064f6879e8ce171bc16c676ebc82c926d2b7d624b6719bca1a26190a57aac65d290167050673189525622c49d586e8b963a35cea0ef4e7ce3c2165f7baab66539afc07c1c308bc668bdaa1156e045a433faa3e7bb9da13e21acad81fb5e7ab648447377c51510f6d5caf3fb6023f7fabe47a3d95c5986c237063c7ac4702606bf3263a5032fc2d217856cb5cb0101357a76fd72f4fd0b67e0d745c070cd7edf83e948a8056fc0664eea1a9bd95bc824d09dea5bc94cf745fa94329a767671db7ae3f1048284f5b797f60563a56f3a3ebcfaeeb1129f0b03c15489f961a73d2a774f40a4e20b7491575b3bdd52a1ddd27a5ee0aa9eeec9514b28a97bea9b335a29dd70baf02cac0ff42a7f9fa3cc4c1ea8be9ff8b66c621ed3af9793373ea66156d81519b28528895864bfe725943b52e19207f3749d1722d209bca125be5fb69fe3940b8c971557d7aaf67c40c98548acc4a02fddf950ff62358876c9ee9cb041c15eab41cd1f548c8e08a796382bca092065e33671075e330046cd72531aea278aadfcc8ecb855f08c76c922479a70bcefe9e2a045420feee3d194d7e3d141681d022ba65c5711e9a524a6b7522b1c7ec4d727c98d22f4baf62d5d16841319bbf33768d7a31364b4edb73127b3b84cce8d4e5da8ece61a8f8dd0fa785c460078010bbfa5038bf6de12c64d4016dd761f7daaf1dc5a11ca4dfba7f564e657b0eba8ee8e04bf220512b8a8d3249fe35cf766cba22737e5365af9063bfa18feb83ee217113ea2c07939169c6d712c92dc1d8212c1c3cc8ea41ca421590acbd5946c3ead66cc563bf561a293301a3a849e276c4fe34cd2763f6b17880deed5420f0897690c64b527253cd3ef278bb72dfbd6fe42e4cbfe6807d6b366704d0482e612ed8125cca1077b6166ee284cf859514477764a23ecc4c25af67dd3aacd5ceebd4d4475a9cd298d3ae87d8b162dd86987d91ba83430b9e6188d61d64e8a83d3e7a727b7a0408831062bbceb341a7a525406c34770a5ab0fee687ff967455e6c777fe9e93b2029c012c71d28e95c4e193de947292fd69b77830d522182abe303e02c005ec8bc50647a71856bb5d07b250480552871085399e5f6091c6e5a3661dc47464aa0cf7e478db0ce262b872bdba9cf21ab35f00cfb21ff5b9a3ab379b470a308cea98c2542debf10b28cf9a2c21d84ace66f6a7bfc899ab960c762fe310192eafd57b46711baeafa252e30db506e88503f3fc71b07a5a08a461e92a68bb312d3aa5a448ec4053a4523f42a37635ff50728fe5a84ffbc81f6e43057e1a5a25caf588bb8fec851f1aa3573ecaa0e78d163fae11551bc9331418aad47ca3893eb6ee9c3eac00ecbce1c25d20916ddb0e4beff414d2e905946d8e1fe44605e8ad3d0d5e404a2a290111140aa24bee49d303e9151636f27a93f9ba98bb54bf76b5483f3088603164b5fcd897b432bfdc99371dda15c03d0b0d5e1b09eb01da88562e69eff82bb197c91b29b98ef3e2f22dfab7eb05fe6a1a8cd7fa47b33b8fc7eef34ffc6335a3fb4278cf9575979ab474d0243b80a536c3e7b7a61a7addbede00ac403ca31e6d3c35150abb5b6bc1d29d164e033582ffa42c6daeefd3e0e861a904766ee11cc806c288a15e08da64427005f90faeaf90373934cb3e497a9e57fbccd42a1afd9d946fa597f559618c37096a39a2d352a012f949972004a994648bdd430bc9f4550fff7f899c42a1045ae5368d7814a627e398ca34dc372c68b08f012a640722a7bde487dcfc66e3283a6db0248480b753ebcc0e57770df62045da578068db50a578505762ce3dc47e7b72a5b7d740cb4c9a3d55ef3999147c1eed9c8811ae4fcf125c20c4db46d009cf7c04e935d485319a7bff9d3533aa6a67094722110736fa2333f24208bf80cf4143796ec63df91cfaf190f480273bc77e29b9e4ead886b90f6daa4c53ee1180f73eb4f42cbc1a8dca936ebf4ea5075c93507eb2c525dbbdd66e3be13137726e06bdaede97cf8763c2076aeebeb88456dad38acc1ee1624a49bd34659b62b1622c503764b0835f0e772a5b99d12a921e7dc7c48026cd46fbffb3d9fdf948dc71d7db9213477212cde0580748984da3d8606d50c12bb5414d636425a295f905cbf2bb2945caf467edcb3449f3de6ca705cf2b1279f7e110ba8f35b0223fda0d5578cde3a9e2c6dfca4e5faef05827b01a5b057373d0a76eb199a8e6c7ec793e679c2984b5ef9e33518017db50e67723f1a51ac49a094c9875515023a209607f8ef63f207d1b9ce2bca8137c87495104308759ba5524c5853a170683ca2a812043fae645ca03f173284f16d41e23b367ef04a7147b659dac21f67c3e6313cd174122c2de40425d8b123d43745dcb19d28a4f40ede6baf2ad8806d7c9a77b65c2f6e7a016ac296f34640b177a1465957c39e95a1daec71bd1805402699c90cde9816eb0fbedcaaaf6b180a7ff9366727a63d1a362b29ae172a01c8d5c5086f0c2b0f87af233eee052463a508e07deae9f69cde1164e367eb9af3623c854604c17593ae3b9af998db21d8025d7b236f6b6565d519b938834bc47d0ca030e820e8938fb82e46546a2f68e73d9c9f84e9a4fbf1df00e080354713ba6093ced52e6ada6f87f4ed2df1162f4a37800e95438cae9297a2121307110ac7598ab3f62e75d481564ac76d78981d5604b3f2993181105659fc44ea426a97ee0726cd6465d14906ab67f2a7124aaf97f20285e14a2c81c32a424ce14cea5e09a7b58eab0c4d6f2d734d167322cf2316043e15b20e58aa88779f52ce2352174713596b0abb5fc480bf749eb4f0667df74584a8b7e3bb845da28847a35c5dd177eabbd7a6c80b19f4b2f0c096f2ef380c05ff17a0beb7900104050dc6079f0c59d4ea77bda6000e61f4c597c74981143db3d2f952601ac974ae97440973f7d5785fdd7e22cf5922ce3a5654f2c6f781c29f8644be6588f068ef24658c9d6a9b194825c369d51491d433b69b56ee7b2b688877d66f252d7db2cee3636db54ace2da2d2d468b307946a62f0c69a15014bbef18e3017cd4f348dcd723f2bd493fff392085abc89d189816532907d2bd6c755fcc8a75383719c2975b749723d39e5ecea171d8717bc7b258de077bda0889cf9f3bc476f2fad110dfda6330c469bd90c75df0c57f45fb1dab9d20531dc7b59834dede67ee3543ab795b3f86a984968dc2f47f3f0b2f4077da7f058fb0ed301207b856afccf43446f0df222ec6afe4bc8ba79b27e323371f340b57edf9ce73545a5ae59d71fb06efc59a634bd41772d645baa9d9de2cf7fa301bb1d9c84a788d65252c24a5e4b1fc5ddbf1f0888f0624bd49e6716e3f1cadbab82b804db96b1f11bb44e403e834215f88ee01bb87bea34cfffbe1744cd31d31b78e601bb2c6bfadeb3538baa6d913508d71b9de713f14af05e06e1fba656c0a51632b6b7f856a7d6bb2dba0ab091227f35ee5f648b17fc9f94585d804c32547609013d7f78e8c02b3dd92c7149be35c9d3f7dcc3db18219b32e6d62480dceb74a2d1227097b3f275a188b88edb2a025a8ac624474b714f05dc5444d873b99e6a385aaf77af10015d7bd6a9ebfc6e1a752dbfecd94a78dc033713ed6b159d0948c98168eacc8d41f281517ddc7b073d39f6d457abcdbf13467e27930e6826f171cf60a25e0e19dccce3bed7075f42098f4e1cdf6661a94b9e099f5df9d3c8394a51a961563acc74a7f5495eebbfa4322407b4a3c31a28e958d7201d120a1b8eddc901bf88639b50fc4508ae0f14ceda38a741382812a61163d816b2702a6bed050968837f8dbc8c7883693805b918cc61797ac3fd3c5f6925dcda0a51c7c034db6aa1956796e67250a215c118f5642745c850cff142a66f9b7950549cef7381baae19a4deb676c370efe1513dce357a3a1a9fadb7bc05af983a613ba237fc98256f9a36a4ed1b5e788fa0a30a7c7ad0f5c9eea0e1ef0f4a5847d82ce224d03a1823d22430d71fb58156765c1dbf79d96868639c1b6297f3ccc5fdacce29c9fa48824b84fb0d97403acc39ccac96d9ddcefe854a22ad774920f63b9e4e8fd14d17701a2c2a4917d3103db0dd232e42b7a821f567f00b291415c4e6dab0d4413776f99de963ebd8b6ae23596bdb7508c2d18c551185eb472c4ba9adb4d31e8d553793be0af7f1eecf56d3b8133ecbfd0c893365db95248abcc415cb1fc13e847d2512ee4621dff83fdbe5631eaca385bac98622900713081f017fbcf68096a343eae3c9ffe9fa299b6e6b44d237e7f952b104ab7ff55d8b4dda45206c0caff95a14e291d8be1023a67839a925b5d619ce474c25d8bad4527888201ad6e213af8d009a57c7e84b397aca784d2f9a9b9bf11db3c8f36cf028d9744e6d33c664a1a21b462aa220e6b09f50e2f3f4f6d79335a5e3b3385a4ffbfa1e13ec438498434aa43b17fe61d13c54116a2643d7ed1eecfd091a71840e868c770bf51ce45f0750359459636a49299dd8719b11714286cc81d569fe85a19abf9f2edb9ff35f7242aac3733fd6bbf2c4b5d36369c1866f1164fb97977c4fe31752882a7e55d4e9c46fb92781c2f49a27bacc04b24ddecf9045ab69557673638a6b22f3e34d9f7e35078b37b3cbae5ac4b2ba4c421ae95f7a589fdbf77c15c4749d1fc5039de05a949b116f365f674273ce60b79059d0bb0caaaab2e68c2c4ea72c10fd35585f0264132c18fe5cb3e417a6137bf62d9e2efeae05fc2900fc0f1bdfac2857d8bc0fad1be87ddd8c7dbb5e132a50ba23e984dda942cba927ef4db1c2bc46b8a5c85058cd37a8567ec45d3be557ab43c5004b6647d3fa9d0a9cdf1e0c9c8073de46d69d0909db615db235a0d50de02739ee4c2a3079ba2d1de864540ed670307b08f681a3329e6247d92a32ade855e2a1be6a2662c160c0e2f0512ff533584c8360f25e5978d5bba0232a801b3fe9d1ebdbdeb3efe2007a06ac6b61eb221c4a041025ad98ad4f28e2e8decee39960f211b3c1e2b3c3685b01dcb9162f7a5439a26a2f35f1d2db66871eafb77073acbd039c1fdba7d923f20e94a943d8187e5cfa009a28653d6a3a208e7ee4e7d86f3349e42f426bc25f0b544f647b27166eb2537ec5107865d70eb58ee1b3b715371c39da71344dc8c6f4c88853d6af8af2e89de3ef8f8563f8a9283e25c9066b6ddfa9464d5cae3bafb1da024037c83b6e14c63f2bd96980fd082c15356f308c2a828a7bb412ed597e7ed7a96d2effe0bd5f8fd4be540d705c5e18f0337d91818f3046516103dc581a9cc1d1c334a8b94666e40bf0c2f0a74f9741b4a494828f949899946b445474d6bb5aece09e0828939d5b640c72818d493a97751044f944dc819542fe155fadeff3a5d9bb1b5683641329168fe4ff376e53b3e45fa2565427312724c460460f5f492d6edb5bf63b39792457ab458c5f6e1afa3b2f95c956a22079c954082b290120abbc49af8d8ed4630535761d495c775b4edff469ec041c03ae4d5ac1d02afa89689098ee0c9828240d83e3ed9cb8a583d0d02b5180e53699062307a3d9594bc7b0a249840241844194718bd77dce3ae8ad6439c91a7d675ba8b4e723b4961fe799ddc31482b5b08095bb47aeabd04cb4af93f46a40a2097401ebcd0982234abf8cc927ab4045da0c5174225afa0fdabdf2d22f04ce387055a33ae1dba142720271ab905be306d063daac58e3eeb8b0bc1543a1fa44d47419c7ff4b65209d1ef877b18d021bc99f59c74b30c4855cd80dac4fbde09c198a8f31d27eea823b70edea58b5a4304471b3e22cb250816898e77dcb78de0dac7238d7eb94d545a7a942ddc7db8253aae335dbd90305cb834de42601ac9ee97f911900c28e51b08cb1063c49b9b60fe3836b02b27f5fe49b6320c0471408016d48b474acc88b2900e98cb03c7bcac8241268ae4ede4691d24e90e510e36b4e246b2ea377fd23bd88d95f7aae58488e7c3a59097173638872a4ccf598fc060c9f0589fa12ca09057a215a55b4a3ce84f3cfc196deea2a9251bcec1ed1388f88e271a4c62effeeeadea164cf729531951ab33bfa3d6c31cd35684a1d3cdbd5bbc0db62dd82749912264ae391906c95ac89477c5a72d0bbe52e475ff7ede10cb7bf01f04e492ba677420c8184d4d71a0613c298bf3c159a59800df2dedeeed7eada65fc0b779976b5c7daeb09fb50577e35263f10d518a3cc2dfbea6a404bf06b3e42bc53e17da1041251f1c45ecb9a78d986b0717b4c1b7d14167f21aae9510d5bfbad69f6774db375fe3689de0c75d9ad6cad7b6c90792a43756aab7a32e3954970eac1e0399b35fc8fae0777bd56a8bfce0938b5d3a42c05624356851370e52f178404585db9d2d90564b627692abd78fc4086cbe1563084cf6f2ff4dca56ce98cf3a5d3454deeee9cb3ffaf6d8ccbc3d5b1b37e522d179a4078c5c6a69034bfd68887623a77734dfd5fe5eb8b51c435f2d6d884a8b4cf0b7afdf6f92be8b924b3992076921d22920416e2976b733142c508c3b55795a3acca83199543d6657709e737397892833903b16cc867c9b232c8b53a8d366bff619ecab8a687b95348529ffab578eaa9118dca8b31c2882daafaebc3ebf6b6090dbbb2e8a3f080e4403d4efa5f6a693e302d1ee5bf8572e861ff001b9aa151ddea95ccf6a26fb544ea8360c64c28cd14248782a0da96e770c64472156ea32af48c1c6a37ec72f48657d3179e2963f66771f9eed84c88fd4704ea6157234883d45949b229514618ba97d862ce4c33554f1497a6bb6aaa57d59664eca93683cc87ea16c4fdce27493161b2323ae225913cfaed705693b8cfb88c28e373d3a25109b3637ce5f7cc8ad7e6a134757b22996f6155b8e72f41450996630e47641f0a8c258fa3c3ab5e94c5315fad1662c8eb4ae91422a7a4e6c41d4ca8449022061595026e65c235dd2034ddca8f937135aafcbf11db101244919429e9120d4fc8d7b853eb6a4c4e90e2820cbf0e8619c4a63f3bf43da69f1d9287beb56ec0b938817c5e2839310eb4935bc631982672d3f75a54de81e75343dcb9bc98a07d266fcd5cc8fa496b4e688c4c8a2c1e42055a8feb4c9949dd2f8bfdbea01ee49852cd3470d1d9759ad340366543d255d0dc102fe39ed422fa221647461a9024deea37e290a1b500b8279a8ec7af5d4af1d8148f4f0e321792a0e9febd4295f43c9c492dd03c93b1f515ce7862e3dd7cf108de8222fa540ed1d0398a012bf11d2f6b7289df1f05f2405927909f4fe68afdd7e3759916bdd00d6eea48704693f9ad4b62e21afe75c97aab335b7f88e9b97c1fb616c1d08cc92794daa8db17897010cf72c3ca9c735b0aa8bd4305163436042141bf08f7afdfecdffd25841a48b8f258918d0cd1e99a2cf0b619f7ef01db3d5a6015765cfe08355cb283fe7bd1015735b0abce09291c4df3fbcb9d071cfd80e87358e1e788a6df40dff3984b094fe4b64a7fb304b1003c8dbc0c8a7fbd365124653af834f377d93210953608f0fd90a03ae7d180468742090f7c67fd625eaa2829de0299babf3f297740ba16f3abaacaa6cb32df7fba3fb8de84f8193c7a71cf579b9a3ee8f8c1f42c4d29fcf40d66e172a45ae52a13cacdb795b5c81c799032d3ab72fd506a6fb52ec63e9835e2a7caf026da16eae2cac7b1fa2b291b0ea50d519d53d63012cb8d3a05136678334454c89503b54af399740ff4814f3dbfdc9c7bef85ee50152666b81154d5745340d8dee1325a6ee78805c4c18913ccf5fad7ae2fe0665bcad836610e2429390807701ff05cac73b2303a0e9648228222ebf570d70c5707012f5e1b0f474fcf3a38bfae043050cb7634949b05887a1e0f584afb6c424e88eeb12362f8e3f469a5693d1c5c1785fadc382d8585cadc2e710d7b6bca8eb449a1f87bc86ad13ef8eab6a1b0e0f02be143c8ef0c6a827c1a923e09f9366a4976d09b9574d61d0f2731505577d4887db342a5b5214bbe883af23e4ae2ae1546b78b5d69834165d66e0d0e77f130b1a671e1e27d79d19a6d6eefc4afbbf38d389474411277910f3128095d48353498bd55025134e106bddd6c840b3631ec51f5bc974f2b04d1c333a9b97e879611e2d118a89a1a7b8e9c450e611c204ec9d9e006989c3fb30d6501800282a14cd8065febe2d2c8d1eb3bc3967c4373faa3ccf503a6b14ac5dd272538ec3f9ba03df2db94ad503ec4b0df188b5e9f90c31bcc0794c7ab4e21891ef091663f41cf780205fff2187546cc21b4e012af2d1e3ecdd8c64acb035b492fcc667271655f5a8e9615adbcda651bef3e9251bf0c85966c1d9e92e9cb2bed50073eb1c277f100a8af9e16230d90473346fe9d03b854a332a3f4fa1e1f7fe6e2fa7ee50e27aeb6050f9fc49f61816672533c4023e1ed8003b9be71d6486f15d8b686adcbf7afcb24ed93e565d11183fd7e09e7c72a2eae9ab751282f02738f9ca912f779efeb21f10b135127fc501c72832759f140d558b0bf0c258273e68b8da16a886209bc4eb754dad998a67cbfc90448326365017fc382d2e94154afeb464ee369b6c0b4df4eeee09245f0172c84b15b0b410657090e1e60a0b46dff46f989682085fc262b3ecd41ed6fd97054d255f758e43259c80cfb0d7c6b3fceb735e182591bae7b98e8f78c5ee2d446947391beb859b16997e471f538e7cc47d8a343b03a225e4098582c6e3d81a2f4e02473c3cdbf53e35d014e5c2c737269a7212579ca1583f6dc262660e3f1030a8245e04a9efdd3882be7b5e04b5f6cf71f3a2e4042e517801b44d2547bc8e033950567241aaee1dfa5dbd2c9470d92b915462e3ffffaaca5ad6428544b12666077583303751ff449065e1f73b7a0e4936bf518aa03b9bd6df35dc4ec5ac41934748b7cbc68e85bfe735196b985391d94bf3d72501014d75c6a64df13fdbe5bffaa2934700770b9fac5e976887d3eb1386fb59446add2e1f248331ee8f9ea618ca774f1d8a8e3f54ee252ef2d9c2420f7b00c8b1b28d8dd039b7c2aec19883eef3db24905519e343e52e8b2731efed5a106fc2c9043569285fcc6872c53fb4e1c1acdc56125ab847e70943bf51654d6d52f962e5f7021912e3e0696d3e3aa149b87b6c72d409ed4f03aaf0319f667d3e12b41fe5aa0b2abc8fa419fab442a13f867ee27e7d67dd7ddbabaa3da5751a377355f54c2e7208665f7c4ff3fc2ab0c286a9e19042f058727a9a0a8acf54a47ce832138315c9f243fc1af8081a59ed9cae403cdf2a7a8f6708e3cf9748b8debfc1359d98b7488fcf66d0151df89cf2ab828241ad54d18cc0191df24f265408d7ab44142195141b7cc470f245b10f8b67d89394558d3ab54dfb6c11556bb7bdbe6c838e6afece09c80a53b907d1ac9f2a6a13a652046a0c42f94f089956fe2150ff1bfe7370fb5c6b01f1d5752f4d45bc9b02b18479d09170923139dba5c85a5a4db9e6f1a59e5f7e19932c3dc1a5bd788f1a356bd51b86a46b930bba149c8dd3df5cb3a283b52a40bc30146994fc679e757e5a2bdd775e8de1be9035d14dfb3d10f983a4d4b3e1d9f22be1a9e10b8787e2b9301be40789bf4825240eb389e2d49c2d7a103994cffa72867301d93ddde4c5b5ecb4c42ad650465faf8e1b0bc73ff061493824ac17aee2cdf6b2be809c2a73b0e40a43f84cab04f854711a966ab307b378222aef403005b6b92c9fafbcde9bd9ea4a94b7a5607376cc2ffefab4fc6881807b45c730797be3f15c53ca9683093bda5b74ec4f56d3fc0526d155ee4c3e52417352afc1896b0fdee64ef36370bca9dd7463c83f10326efd248df42577ea430e3e29348f53973eda02887f505b9c8e1cac5729ec933bb916bc69f8062693da144f6b62cd5f1e741d580a19a9b3c41344011011c6c3c76a8f44da7d64925b93532950260263b1a0de9d2263b5fc24bec8b615e609dec4b78e2e965168e6021d0b88a0c4727eadc8ddf03d9727c7d06d04cc3e20189f53cb49ac8f4cef30b42ea4566d52f0a95f9c569a68d8916c742a3ee3772c119b925584bf566e880f23ec44bb8d73a165dd88d43d1a3bf3c67656a7f1a43c824faee3efe9843f75dac589e19026385770b218ad06cf2f392849c5767f7a242f3021dc0ba552ddb04e7b26c1e2adb1e50558fbc9d82b537ce0bd8999633594becbe517ded1d00ab9eae479e7c5f85b964b9e532c26e95dcdde0144178632b0223bdd77a327899247e782f0addd8c89b482569e4f6c1e85259de8abcfb114b4782a60ae96a11da40de146686665aef380ddfc30a68f297ba2076b6a977a68ec0bcc66c7e8fac74328b5ae139afca1b6ace4013f53a1d3c1d441e59b1a754d64c9ec352ad365f02dadf593fcc07035d3309369d8b4be040d76e1eb6e0377a3a271aa03eb2da68fb4369c9e3ba56cd5685a5c656ef3ba663f69696a4e244b691f4f69fbe3893074c7817b9ba97fccc16d3a9ace149c7dbb4d07dcbdcb86226b7b597f400bf27d422dfb9edcb86741eb20232ba7f478c1a5a089c3ee929cc911595464cde06d3a03088a285950a98e124fa14054179628f16fc5facb93c379228f57330e7594d65ce6a04c1498bf3aece634ad7a960094abeaad1487c2d9f86229348a2c4f0756109faab1bb81417b1bbcf33d52b1f11d2074889e6f65472a9c994eb909862f503b9d307783aa9f6603f73f8e6660cf8097d114400f3c0f96bab7e3c99f3fa4f694756b985e4c9c76ada0cbc39099cc547b41d573654d983340bae462a44dabf3a80240e5c36597192cec0ca090d8c1b8ada10d4ab3f0dfbef53df953ddeed7bfc4109fc6dc5b064596c40a0cf50793158a97732e5f14f2bfa35cdd696f150a930f6bd4f422bb3829f62426bbef23a516bb7a549bf317609aef60b175610eeabc61bef80b0217dbd84a4892ef5bf338b355d3ef598c30c9bc2b9fd79eea787875f375d06f646179eb3052ba50858eee0c5d370e8f7b111f6f00379fc953cc1aa4f20de56c6ca009e24a9237c867310a321caa86a13e6278bddb50b9039c0e744dfeab4d59bc52c232effcd1a44812af5da680e9118547edb83d5cf5f7d23b6f6d3196886d74c77b588f3cc21fe706230434220da2d73d8dc2355e246e8b760fd7e9dc5a65dbd857bd1c12c4152fe63994bf359273df72f039cd06059076b79adadfa472bea6c6912ee168a196ba98da7a2d8892ec03bc293ddedf28e170df768817928312ca47910fd264008b4d70d5eacdca23a6b0c88527afa1b56f02fa153ae777b14870f226e41ece6be4b120d3f243dacf0e286d8fa5c2e1b60c9c2dfe4c49673efb504212ec1c34b9bf8570372d3ae45dca19f3757d6df3dd6f2c6c87e6b39c6168ee117b9194008b4055c3b251a00578daeba6d26e7df458e3590b112ab34aee34f33ead7a0a521c8ffb3ec6e4043d6773e65d95d8b7a5bb11c09a67f1f4cf66de89c5f0f342ed7a16b56ebe6e23498b49c965fe403b86d8e39ac28d2f971733527d55dd9dfd734e7d63e12877b1333a9fd633417e479762ba0309deb4255a401200ac0a13133e2794b848a5e83ae8c2ae9a40af90978195a09c71c0936e7aa56c4ed42e373aa2b4fb3c95dacfcfdad1da1fafc3d53b47e19198587a8021be44417839b978ce4d7827183bafb49b061544465a5c4a077bef917084ea8d764da88556db2301819c3fb8453094019c49051e9cdc063ba9dd095a76f82ab416a49e1740b871ee680220f40c286a5199aac32199c62702a347c0e42a8173fa5c31e6ae331ed5f0266da5fd44fa4fb935397c25cfe4d8d2be07433daf728879de14752b9cef52830a254dd64f5cfd8961e6340eb29f16bea128bc496a89d30f7f6fc61f72732518935d054464b323c4e79e95ceac762563d6f0e100202e51e8a7b1ee7c3dff93421dc134b7e0e74ed6ecd2266c4309960732d4eb73996921c48ab6d050d6c14cfa73f2d845d42f96fd373d18a8a6cdc6ad82d4fd8e0f27f6479b89bba7c1c6fb63d97c8e42394e4b21ece34cddda4a710efdf5b2813caa2a61314beec0be50b660c73da33f077c84638e7f844d9c751763ba74c0ca25ac9142359146a2c6448e0cb45ac9fff747b3c825e8e34f36fa7fa380d1726ff6254cffd5c040f17a2ba3835209a54ac766855fd680e03511befea710a854b5d1d580c92c820d9ac4518636b95397246831efee6964b537c24d1f2ead3d692cbb67e3f11ddad1a2670a5a7a443756a542f4661d356e39befa9622727bdba65383102144f4a606d27cf90f646b3050c010761e6b3a9271f901370f17258a96916c987e6917190","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f9d8235ae34d6bcbb22a808c55ba055f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
