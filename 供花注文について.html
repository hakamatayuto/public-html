<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>供花について</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">供花について</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58c88062c261c67ce1b15341766bf5851240e70f885ae14d112fffa550cee4b8aaa4f7e7e2c30e688a16db940665ca23960f8b12c1647e141eb90a1dc3dfb31c8819eeb47ba14d30b6aeeb505a60b08187cb6a61d34b08e6cc17766b5ea04c7b45f792aa09c3fecd495253de8d17bf41dfa3d2745a95cebd62297b60086605e14b148d84b9b14c01c77ad1e864f69b5b4fdf51a1a374f209616427ef8202ba5a1211f5631177fb7bbf9d46fd631d8274d9f54b0c1271dd7a16ea49021d56d5c3bbdf95f6e3eaa29eb6331e563845bfb250ef3d58dad696d25ee4ab8d8d8e0dac10cdfff7530ee6073e71c6b49d08bff3238b890398a6a23ee40a1b96c3e72c336d006dff27f0a3e32b722158b24e1903931ba24523c44dd56fb75482c7ca3bbc7dc441d772a9ab7a70d3a72b83a85fe025ac34004f8a105bfe5505f90c8d5439b1208f7416678e841cd260b9608c67f4a0c3de486ad3044eead94ae37981d6dbccc086203f599a64746a7a86e831a5a49345cde9b104ba2fe296fb4b2dd3c5050fa9c3b87aa5b05a23bbc44229e1b8b984e0495b817d29e0a15b8302c26461d1ffe51afa0c4998a9210374bb882f36d8ddcdf78f038d5536c6e12fb5bcfcc36c1cb8ab9fb53e27acc67dfa760b8c1099e9962d1eaae4189640e9620d33f2787081a23272367d6b65fd284f766fd7ac415305fe72491a8232646066db259fe979020b4e9c2809b79c7b797e0d029208c958639b0468806b0d56207ae07070607b29d6921954d48ea28eaffe87cc2bbfb7d66a00f844aa5cda65a7143c003f4522d2a752feb6b6febb0fae0a3fb95e86ecbe128ba40aeaebb1221675b84447cbfda8a9d1811f4a0c27c5ab9df8bd269cb4d91667af4f9f29579dc4cc6a6ef945f2d6d81acace259b3d04edea11df9e292809468029f4e4659dd467fa96a7a3ae8276d334cc64b7ed1a0c506e8ea4f9c7af829487c7dad5257b69f44753561026b673d0d982147c49de562ce82a8fd31538d5164d94cde372328fea9509894160dbe217b3f81d6579fe648583c7cf7b1a863d6dc45745fb8c7b3d179082ae6391d404143c8e1b1e3dcfdf575033c702f3957e9e43170b03ab80f18e6ac6ec18b1593024b8996a3a4fd2e2554413fc93dc674993faac626f975bd51debe0d0b36832bfd84f00727411bdfb7873e51db76cab5c21d58a5c52750c615ae7d4832cd2b51a1424b74107b2e4e97b5d0ba0cdf881b93cc855ab4664c9935ed932a56dc5090a7094d224d394db6b0d10a915aa5686641b8c8a7404ef095908f26458c427016bf67a4d7a7ea355a69dd5d828b17ffecc7ca98934629605b775b3ec9325e6803c70e5026be1ec2d1d984cf3dce644e8b95e721ba4a868935537934b17a52e94a9df25b6437520ff4ebd87e3946929e5bbc7123ddbc1d2dbfc9f706eace371092ac36aeb64ec72b508285e8000e2610fb8749cde35f96913ba103f835743efc1fed56d090d41a19caf2c1325cc0dacff3e760442a463fc39dbbcce6a15d34631f28f0179c601ecdd1d1794771457169ad2a6c9664ff841f4e798c80ee23b092e71bc2db5bf09f125daf9437b34a17195962f759b9ed0a39f1554dd2856bd470ced9f4412435922894f7fa4d37518c4c1ef7ed6afc942b7dc99b0c91d8a4fcfe81971ab726fcf29f37c489b153eeca4e19bb6515ce1967eff7301619cf345fe6d4e7ba757a33bd4b6312e1daa1c8481732dff13e8a864985606275841e1cd2d852f970a9f6d13c6babdb432eb7ba5044e2aa8081f3b2ab48d28bedc8a5e5ab9942592877d93465ed4d2e42e594817059f5af8f2525bb8362829dd70b4c8090786042e32e925b48ab8d296e19563f8945592f888fa3745c0ad2381a378c5325cb26d8a8e55e13558f152dbf3893d9e3c8caed34b79c542e929a67328180c7e898ac604ddabf2238b31d4778ae4aea232d68b8cb7d83fd59287683cebeea7e20a45da8799a87bd40b7ede5b72c285b9baab8b16d6e5df0aec277901fb482d2e2f120bd17f2cba0c4a62efb6ce3bcb0ca23614b3b00e2221be6044a3e379031e42caaab172900bf84d8b8a56260d78a7ba4f748e131876216f3f0db96740142087c4f469b919c5fc6afee474c9f89314068ae99d05b75c66d4f79f4c020b03820d688e974307cd0adc0d92947006e5f60d14c2d63c8b0d87c2833afb462e8089ad4d4b6364d6fc8e6b3a9507b83c1148dd7f4a91359358bc15e929e23f82f3b5b03ee932f21c69f4243a1b2f2ddf15f035a51eda30d8313a8d7f8e4341192fed83008ebfa5fcdaaa0108ee110caf2b35e0d6892814d50c3be5e55e7e25117efc200d49c3b72fb1e6b6104fc214b9fd226bd580315cbb4716270f3403c867867c662425fe6c4fccca93b9dd8e936fab5d02e1fb48ec63306a024c2bf35e49526fdb9e1466898b9e0b56a3061f43eda8681ed20479ae8c97dee30f970539798807344318b30e4316d5b7c2991b84ce12bf9aaf8b8c58c1964f196bc889b1559e61f4717ee022c8c7b281f61f2d8650447c58cafc281f9977c6dd6ec922afa33c86dc754fa9c90b4fba907ff56aa1b74408bceee1d2bcf79ee5b5f4deabc6ef15fa281024f5cd3831e713ad9d14456a69c1c3fa4e383f6adbde8bffece251c087a20e5695af8732a64461e4c04c222fbae90ca1bb9a5329369e227ec09edab91aedf403d7493a82c1e799e1de9b7409ff866cdd07ff8f44dfbe8420ac4d0ccca35b540c84179a7a0c9e18a1a8aa96438f8f3d76f53bd382329447c36e64476a106a8b63bf3521a3c91434be6b69c3dafa5c41011149d8336ccfeced69b67b866020815b82fced6a4f0510f171a02c96df758f18b409c6ff1d59edcb0549a6631d03c09361dd384e5e8ff68a180704fecae5eabc41bd134aa57e03c063763586cd31d1cb6470b61fb22eb784115925b161315a10dbbd330a4be8f551a0c428de7e93944949c530aa8005d60a62e3ddd668e6c0cf9f4ea4b318f1828d35dfb794d20aedd626884c1de91883674cc2ae04923a2ee6d1fff344bed24426fff5ad9811c917213f481af75b8e2362995dc9b7974ef5fb82aa417e6bb73913527616fb23bb890e9fbc13bdbcdcec66f89eb1039c044b8d98f65052b70303a77cd1b84b0c699ddcfd4964b985475e3ebcbb79b52b592f4593aa254e5ab6cf1d325b87904ed8cb417476a72aeddbf3ccee4158dd2ce17d36b214efbe9d1ff3cd9f815acf6043f803d64db4840124ab3cab33bf66129c6a000cfb2c6f8362e7f88cd3a141f02e20ce80df3f68339306e9a504fe9c5946eec4bf9e51135eea99b282f087f9eb01a8da93cc70b7d1b4a42a770c42f924a015262e5a1808ddaadcbc06a04aaf28172e51ce2b7eaff364f408c618f22df89ff17ed618116945b90a4c0fe9a993b84deb7a4fd260cad8f20bac0fa0029cf2920c908a39900905c7759687a949d31bb02dabeaf49a5a13dc878564f3fb8293dd8a40b38d92c4998aa37cc4b4507acd230c3c0bc20031ec7a676568d0c757de278442710b66f16fb392aa955056f8af232cf86ed0daa26627651363397bfdc81ea4e29ab30f509e6b484972d59514dc0cc6fb5b84ecb113424de5a3da72b82246985b3b408294e3bcca60ba84ee483a7cff8c7805d48d9fe889d37528ec83603a1fa8cb56b985c2f0653b163d360b80cb3ccd5427627b399457aa97a1b11ec7b857560dd67320cc1a09c3e8fc43e2b9b6803a0c14df6d45ae60d16a1b33d7ebb697ebe4ddfbe285016c10a415826e1d297128e764a59e124ebc5a8e114a870334d50fd3a0ce555a2ddd03fdd5b3bbe70ad1ea78a2f2d0e4f82f2da0016f6420d40e009d8ebfea8f94f22ff52b2a60989382a0ca3f23a70667292360f0295a2de0b5472748ad0fb6f084978533fd9d7137495834feccc069441fc206e9765d992240ab732c7606791207823b4d0f4cc53c4498b5c910fef4abc10f4d425e12a31362a25fc6491ca92d658a39270c68cac2686029b57736623eb139e33b8c9d80583b3961ee4b9dcc01476f3b937e9df9cf02cc3b8c1c045a8c0f36cc51bcc4d36f42070994d62ab039a05111fd16261af96b627b954786d06ffbe517b01e6f37d8209b19187c6a5ab4f424db7321c73e37cff18829231e00c034b6060baa20c417822964e568c33dd56db990c9bfaba7de9f72fd7e01450bf04a4b63fb9e07f8b54d65b947835b267bd1e23a8c73e8ec53b2865d023c222692fa97db6d300e1bfb0f693642748e81097e1a5bce8fd24e6037b11997952d7c488d8c3b9504cb195ffd7165b90a8a8fe4b4e69f24ef66a9eda1b3aa76293928b17612757a8243fa37d476b74b48a6cae557a257e6329d294d07e8a780b8bccfd34af70bf818f3e8ccda0281297229beb423dc4929728c57c8a62594e6cad6ce3c85b4a748a4bcb92c103930a8a98582827bb03af1b32f02c6d06e7ce6eb881855b2506946693a714f407a1d592242bc11aa2a146eee2f544ba17dfa1aa48978bc9327aa42f1f2789d682f4364304e17edb57f908511f5a58565c55e536150d9c1d2cb237d2ce4f36f52c16323685857fc20f9261b4aa79f066f6447fc14535363b32c53597f1877295b1bbedb9ac361166e28caebf6115900da775fdaa103630fcdcbb883c5dd3963e30433cd79f3fa7800d73032589ab0aed356531d64c91620aa3072e84064ec97910fb43ba48887cb0cfc5e9708edde7f8988f8cfb4c6aef004c00bad2148e06ede9c6a144caa8f3f7369c598a6f9088d613dab6befdd78467ba13e1792cedcf78d53a5fa3c4ba8ff45fbae8332c119a8c13e526c63af5afd7f30933d2c17b8ed36ab643b7c5ce9dc2c2bd0b6ff90ec9df5785cb0a2c75c269a9d6ef3d3fe596934fabad5a9f5cf7550ca6bcbf3cf7d431700aef58b7213c5e2816f0c72cb3ab0a2e3c940c121d1ec1a7a6a050a7a6feb89bcca95bd7f1630ff44e34ace4f03cbfb5c3db56d177a8ac92ee0c42dd317c9ae037e9dfd4312911ba9b6e769fabca75759f9fad98122763a2ec7225de8cfd6f367919c251fb8d41dac09aee71b469cc2504ab03ab37c25c0a63241c08fd16e3adb5cb37411ed3a4b219c7668202836f46055723e0c11d2ea539bfa36a1812933169c2410d9715a0203a55b449021df7e07b7673f4c66479cb33cf0339e4ca1e6e69ad6354c266c15b11836de880ca9901bdcaa3e8e38111fd0546d98fe97d9195c3a4c3a4935dcad50f844b2cc1e240940f094d9b948e4f900af17857a6d5f3a7aab21937d463d07aa002b8aae8e94d14d49e640de4ce11bf5322dedb32d688fcb358aa38aed4f468623b45f749dad49bf77bbd602af54f1e6968301dfcbeacc0811c6d22d4be2b4aecf7d7c27434046a0ef61c4355c694e72ce89b09e37b119f199d1a9fa447270c5cbde14de265c8addc00d171494b4582bf4dfbb5a17250641a05f12a183a24fc11cf4482b9e2c013f604086817b4028c003bbd8e7942ce6de8e0b362a024e2cdf9e12d909311aa705f7c1d718009191bf2b487e6f182aa222de5144b4af494e5c205a38b52f80a409c8dd5c73820bf0dd7779cd27c7d69e9072cc8455136372d33920cfd9f6276c601de46dcffab86410eac1a74010111b5220c8abb246e3bb944f0845bbeb10af31a4f69307135167c0022f2cbe59002b8e70d620ed3d524b6ead79038571d6fed713adcd73433827ac13eac5df17dda73624edac13d39229dc2ea1efdc1efd4b0686d66742f83e625c7658446d1dbf7291402f919e8b48b9ca8afcae6395862f0d082ffb217ad948ef1a82cdccf493ad793ff6dcf18e443ed51f4d2ea68a2856edc8effd406c1fe6f796fce03d9c46abf9550b3109fdf61184b26c8a9c21209084b5825a073b7fa06b1d12a47cf6af271b361ff9a6390e120f3e62bab73665e3adecd6603db4ca190230f34f50f422133b270b08b1d4494efbb9cbea1f81088aff23ecbe4c7c2c82cab136e538430c5463348070114df6ae5a10ce8fb19560156d0112b5181e14e71004b21e6748dea7313c1f1ef6f410d060fee973f6f89b3cd11550cab40356495562d7001816432605b320085c3f5a4a881069dc4c1a104c517675d7e1dea1c1e1703a872071420e94baed1051b85bc8ed26c8bd0d2dd43a3a4b886a8dc70097e41205a238a36133921cda94ece7d692f3cd84e550b5f6fee5291e247941479d202e759605b8afc5ffe7fd62d456f27caaf4dfbd3e749c699b4019aed91c710852e5153df0bd6a5ec18edba113aa83d37d68812db1da6bf88bdd510a92a8fad683ca33c45c05be4947b1909a16d45625aa118902d517dbd8568295edb14b1d965a4d91928fea83bf7dd1d7c3b58861726226bdce73c2464c8cb491a0f4bc81bac43eb634fc8c013034933bd6133a435c95f16218b79507319dda6f1ec6582c66241eb901bf3a4bcbbf7abbfe38e4365842b63c3f22a0b1bdb30ab264939dc0d2e8e1926789696a99135c52bf21f0e7c7ab7849ba97e41a209f5e22e3a0bcbd2e33e7f964528bccc0d1ead87130053d36d959c3841961b15426563dd965360322ba2ec7f610184fc613e1434e1ce3a1508ac57577baa3f398450b42689616543d031ae65fb7a75891ce9b115f330c4ce3f57ce1f1ec7105209f91bfc8b02f4fd833ea521693f41b2809378798f4fa81005cee1eabd19090f979e3c0403360d97549eb29fe67b504ed06581ec295ea0ac9b9b8e3a6f4c0af4473cad63f517ee2ffed41d5082e49c20d57e33b57c63f41151e7b0f47b83fa3baac1157e9ce33a729f27243957fc66ce8617bde430369aae982765ea85613cc465f37c3f8aa41f9ae414e71286fd6ba00cae246b1d24c2cfe9cf4eadae5b718d281c149b652c2fb2ddc8a48773c753e0ed8ab2c20c3ad2a7e4c472a932038a68a287ca60300c651daed33f2f3452d7e2be7ed53b4b1ccf0ef562d5c14bd6c72ced61508c2027cca6ed88e4b45485de4fea52bb75742d924b9fde672fc09e5b673351d4fa49cf0331523d3c4e4d63eb2deb9909f66518076db85c7ee75e3a044be131953a8536a63f35ef99ccdf12388086d8409a1b4f1a44fd5d402817abd7ae0b1f1c39a000530e57a5af0fec1ad90a0f7ad23e19a6b40423391914c163ba42687dfcfb0a8098b807e20729e278f7219346a7138af31f3cefe49bf747fd35c0c504b4869b6cc9f45683244271ebc5cdfda0e0907dc2e5676bda921d4bceaba315ad8dd17af451bc10b4c76b42d3df028d6a3a35bef4cbf64e8e52ae37387969bab3317eedf3fed7225677aee575d450f29add5b391836712b5fb192b0e07ce214eabec9683a8a99218a109226d87466c95707783e8d03fefbbe546aa13d67f83ab286858905faa780005282827cecc71de6ab9536dd716ed0a79eef963d58640a0bd572eb9d28794371a94f019f5c9cb340232ac3215f524b65dbc003be10c8508f68604ffc35449b63b103f578cd4553e3fa7f96ca7d35629cd0dad327242c53e0d85ad6d9f860186393c442982fe843188cc52da2ca2a0170671dc0fc5424e07a54b245ebb96dbd90f3b3ab282d4d001f5e959d9e5a6c45358001cdaaae7b6f68f23869b2c0e02176ac06c28c0c33a1a144333e240af17154b24fc877c3b57112ea43db9ac39a8a01367a90ababd71cda2a58ed9e0f3c1e2cc637184e77386b7209e2dd904df1c2cbc227ddcc8f48360f3afeb6c5393bc038c75f7ed151f7044cdb62cf08adb8d30d396ab31d4f5c5c3ea46ea27687aa3e934eee3271e02c006bec31856981432b4946e3704ce32e24ad19becae427145676b242f31ad24365c0c3d8ce88ab7d95374c025d08fb8ac88bf7331fd85699b31cefa4715b090ad86de6d2fd3a83a2460090d5ac1118a08489b1827f10c7a15fd1d2a9922a87ef071054044164595ba7c603cd50f1c9153b79c3702096e65bc4836e82c2dc506002400e3cef3fef419cca77f68496358c7589fac84b76b3085449b508a4d56649a7e0e7b91da313d19f57a5e8a79d16732a761bce57baae94567768f8e2105c6b5437337a1d548b54e5ef5151164203b1a58b17ad143efc96a87883d2b95aa756e89040c3dba868c4d25a65f374691761223b4533e608334e16bb08f36f6648de72d321bccc5d2b20f4f15c1790b3cb30f1fa439ea909a3a92e06a8f38f2981dc4fe4e2ba82d927e3ba97a0843bce1b1e521ac6bcd2960428d6450f2c4509b2e9620c60c6430072246012d763e89a877ca03017118fa596943f0acc70d656a5ef5189fe780d39d3a3fc86be1bae8cd46a3a2e94ccd30f3f1e70a5532b42d31d3c88cac6a81e85f8f6b613ab64e13d6d54547a75d6af24916011711bf664f7c8b6ab162d37ec4d34cfd22d5e6f10c8b176aff5263439d0990dc1f81d82bc4779e98b232ccf858ca8594217eeb3dda4d86eecd1eaa8fc7b8001ea979bad4c2fc351cdbfa1551100220bf55628e57430fcc2024e320d7d639227da3f58142fc518dbe2edf3df2d9de68fcc71702be1e33f74c4b37ea2fe88cf51296746a79493f9599295f9c1194b202250d4ff1aab79c3d14f76c355ba8b81aa3c5fbf97e2ccc06887fc5e3119b189a93e3ad9fe30361f264af0ae14ad86c9baf8f9e796fbec676540ace66781853b24e2d9adee7ec795ec501e3b62e139c445871c9bfb1e6d3b581becda47b22e44749742867a2ef7ac17aee5ff913c5db0c906f36d89386737a8231b79b6a9b380671d322afbfbf6f89a50a7e91b1e119e01f9dd2fd650ff19e583bec9de333cd65b6a842055026f2897798fce98ecbd89693b5fc26b6b3d5965885a781040633012dc9c81031b382ac0dada12b62905ded02f774d36cdc551b160e62985bc33a869b3dfa4ad2aec3059f6ee286045d2167d9dd4837ea96b3030c62df173d89a4e16084050ab24fc50977e4902c3a2d8effc89ab3c8fb6bf2d4434a8c2c0c4acfbacec67eb23643855d39596af10ce28876d5629efa5789e69e9bc6d5c58f0d692de761e8c49c250a7bda9393c0486cd6dc911f84aacbe5adeae1659b640dbbd95c735997fe30486c2e79cd17850b718edefe5390476486d8389a9377e3956c7fdd28b2af08dacca9816510afa670f6f65e2f4b16d0da6d4b19b86cb85c6f3ea4c9c4937ae80530c84e7c6a823ffa0744cb042f89388cbe2be09908d4a5459b7687870d5b4c90aba94674ba14d76f7c5191a99c159b3d12cf83a0ea9b4335dec9db40713df4b077ad638b448e2bdb17630bcec6639b75395a7f6dd931f23d346d5ae594671612ee090ca9241013c49eafc1a646d6b489545dc6fc64e10aa9205ce48ff18e1c68b2caaf7d49469b7b14461b49d9726c8905dd9192e185ddde568ec8cedd78280385e335bb5c88c8350621cf7c9b6b27a4d208fc300e49d780e661d992dbb2c229836ed38f8a7a59a0d2577b928d6f7c70edcf7ad47fca49dff67621f88c487e0d550671c342b7affd1936b28bd7a1d18b136d0a8a963b3f4d4313ec70fd01f789d8253d221c568aa117c18958be841469141f6ae893af1cbe627b3b524ec1b8ffc6d375c32778a0da653351b47d486f101a50b48111aac20622f1008fec42a0ddd516c933e0c0130e6914b072da2b8c686a8f380e8307406682154d16557dd1e5b7aac0e5159c8be0898605d525803a9e42c6971004e06640401ff78117ea147203fb09d84e8a23f42c896c422bb3304d8b1547aa5dda5728461ef92fbbbdb595f3f96e76f9904e19be10f23852bc6e017495fbe9c47911a6f3720702cb7c86ff3a3f4ff3a127ad9befe8291157832f15cf5534f75a4248cf78248ff9f62181793f10fa6ebd6256da69e1b8daefd9b0f965390c31dcef71b12a9855e879bc6b4a3b87c87088af9a16768e0734eadfcfa22f1131ae8e8f6ecf8d329bc608b12b1a4e9eca62c0e93f2fa5ea7cdbda64a8aeafc7cc96d768dec7bc4989f6fd78a39f329fb8c40fb847a9f5f938cb3c3ea0a465c53806428a8875f9af84d01c29f116c2f6928ca6b402e2fb3ab189eeed2297774e799edc685e4268d91415effd66e0652f16c37b0ca5920107a0143fcb5e9c33b564e254e7b5ece9f11161a45235e1b0940ee59c0d31ba29992b8dbaf2dda2ad4039452181a89cdc6dcde61fcfa411b9ae3cf7ff7bcbf036e94ab82aaaa545ea74da17e543fe5c60d1e6399012edff639f0d8fc69333bd768912a35ffadecc6b4c1b738a1d1e443d8b2f771da27e3ba801e253df26edccb9597716fbf968ab2eb6cd84960731734151fc4be0155757f130d56a780cbe55f33b8917df0fcc5d61ed6321393556276d6df4abb701a3a254fe53529270066b9d2a9fd766caa1efd30fc09a7260931e13aadac64355960dca13a295101ff9a8e82aeaf7812947cf1ed83c5b5733b903c5d5f943d97e1448a323758c6dd7a5e113fb8a9bd013dce2af1125cc5164eb2c96a58e903ff002a688ce134013d49725c21f7fdb4bcb1cbf0779942fd9b96694a1bc7c2d0cb2ac0907889e046d0cee6d127cc45448b886704843d60173eb8a94d3d882133ff235f128f1e0ec9702e82bd425b7fb8735a889c18c904f905d66e704810ab8a9f1ed69cc3b0dcd44c364417c031f30c275f17f2f8874905a21e7e141664eb2e2fb0cf01fd3808b4a68cfba822fda0f2b606d7a65aee801c7b574c62c85fa06e97ff8ef53f93e056c52cc3257cae354f2d66933d783b68c4dcf5ffe7906b30ce0a3b60a11fdc5b24e8e0ddfddac5fca69447738869dd4f65d6ad15df0d0134f06627c212a3e1ceeadeb32afcffb8e56a12250422f6ba33fdfa4d1d1244202e4aaccaafee03964992b6881a8e7bc5a684cf6c0f4ab79cd825ca0a45a6bbdc3e899d93d9bea138da108c5743658f5b5e9639637dbf79f92a751509b7881dc356de5309c04256d0a35d6f56cc006a47a51a70245e212e7486ae11087461c187d705e7b63ffb6c0ff7a85980024a13b841f0bc88cae4787842a745d3ec7831b6582adfc92c8b4f10da6bbc26179317fb67cf5efd36693880a2136b752018075f88970b5a943cad590b217b62bc6aa4918014a6ca6aa09434ac8a525b2a0b60271e11597875621ef67c87d93b892d1e52138e7a653b358d660a5274817f2ed498329b306935b1ce8ea7db84dc73194704e90ab17556f713851adf32578b575eebada8576e5d15f10e77a98024a045f96a2876e7083e7d3d84b71cacca2ccf9633700049b7d3cb96a0de2b4d83f8951a373e027c67a5fb13773039335ff12ec3943cb10bbf9d26b511360e547d5594b339c96e138d92dabf76b151e7f9aef577a73dfacbb8f1aef5f84d6ef382c4f73db38f1f4048a84c38e3032bb688fd627c855e04c1f2588f7c5b638cba2d110b1ec82378bec3b22d1e7e51df05219bd1ee8ce7369ce6f1661e9c0be689bc871c2879e2c56de88cb421b6201fda42a4f762689269a8310d90dbf0d16bdfe94c9170dbe3387b075cb48a5be8dbc736217f6643b9e013a6b13f4d2252cb50f471433d4d5ce59866264ffe915c2cf478ce1cf06a4fde24436a5c62d41ff36e266fee9129f2710444314876fb71ef913bf99bf3c17bbf148eb445233978d3ae4c7d6a5f1666629f3370c7cb2a536a474d5485b07e7bd4077b4fb81e92dfdce0b43be6701ec55a245f418ab4abf2f045ef8a467b9698337a5afc6b688db61f404e66ce45b51b3b88a8b379d2c7190ff8fd77b9c38e7ee6f57fb0146499ef7854c42c65bbb64f3f69574db2e416b05a67e3aa88cf182cec8f6480abc7feb849641e057d7cad31a97f88f8083b4c85d956b4c4d6865e13a1a619df2a080300b132c7dfb29cd07e2b588ff7b3db1e47494ed7c1ffa5a12820d2617322b810f8b6ff7425d17c0bf4809ee1fa32548f35d876fce85c3ac3c5fe02a02809a7946546b6c6bd27efb4582ce225690083e5461323739465d9b1e70a50d2370c3f126e720db087e9bda3b2462a72b149004244bf0ebcab3517d7c8cc3fba80512d750ebba8c4b2d8c564f51fbf60c6ff81527187ee80ce9f015a569908986db1ac724e7a6fa8f68ca26b2e3df581335dc84a536cdc4dbee85e17da6f164f6fea05b321b0540f5e57b7eb16a19f744aa81bb0038eb96dbe5981bf4d00c2826981b401b950b370e768bc3f15b03bbe79ee9268ae89e7ff17b939b710480d2095b56c990778da662f8f52592224e6e8de42baba032d91af9c9ed96835497d970c10034e17b5cc597b50e1308edaec353054aaa112bab05f996f461c9f798a792f26c11ac4c23a611c8d69ca78424ca0f9209b1cd86ab8496c9baa66b68adc5c9a687aeca6931d8f0fdbfc2c642b2294e96cba865cd86d916a2d433d3736eab7cc39207e72703ada2b101e4925bfd15c4c2c87bf9aaf9a7a064650e083d0cdd003301ee7dd183175940fb8f1103b58eb93cefb30dc463d9af654f77092685d854a9b57d0d41d7b08034070767834a1a2be2fbeb1900ba24cb229bab33089e4b58a8ac405d8d63bad60febb8cc960096735721543956d3d2330e2c9292890e55dbe2a225690535e526930df0d6784e9b567a40f8f86b2ca55c4a782a7a7861c3a5e8f4ca754d913ce0e01a8ebd0e3170a65cb09e58bf0d3a4c33696a0c4a297c038e14b4e834f206e005d90b8490b0e7da9333b05f720eec45049e93053e41cf66b879b2f965af926a894353c2789e0e139b074d9061a1611c2654f26857a2d500b9f989af38d9f77c3b3b40118d1588e1e48ddf6e7806a04a2cb1d51a6a44654afa2b2bea9fe9c29fc244630f004351d33f58f12c4d755574666d1e216c61f03ba46f449aee6d491a98fe92d37aaa5db5b296d7303b25ced2d2e52f3887640e22fa57cff9fcc000b3acd4b606f896b18bfffcfa3078723b05276784f8f760ac8cc034232ab9cc05b5ea239ddb207d0c13f4c756df2ba50a74fd9431201d84d3ce51fff882169511f8494f2f9acdedb4677cc60938cff0a96afa7bf524260607e02ddc18eafc8fdebca6a3439a95aa28cbb05bf3a6f15ad97e98d0090f2f2d0a93fead3df886d9c1637e1c6e279cbe2ed76bd5c7e3483015c954d558b7e0ae0fb02a2c38c9bb8f4bbaff3cacf92f14b415893e470a7095be4b26d7e15be2108ff0b366ead0d4f9f20fc24d5b227c5cc774cdbb825a0ae293771a133ad847161ea5761e7b7899a5480fd0253991855d7b62059f0eb0956092beecf41cf4607db0c9ca92e5af918b7563b925080b5678283146aee0f60635aeb39f7e8f671a5c0df8ccdafc91ac456767da3c9608638bb5e01a978375df3d19fcff30650f1221245e3d8183a4d25139cb6c90e133f0b4caf30084b64b175ed51f18fae56ad50f58e49a9ffae4621e14cb342e6f205758dff8529922829f1fe134ece2a67d5489ba1a74557b0e1c8256b0604126dbdfaac786d69c34eaaca767c56bf0004ad68b98193da47b4a5fc451334b6be7be66a991b5d5a9ffbfc6cd4118bccea5fe682d5924298396dd25b24ee0ccf74515b4e172d7e7a6c3d7cce1320459243769b85c9cb9bf5b1ed7fa942211fe2e4674219e6080fc89a70b5e626165a879f333cf455773e586e44f64e09674a4365249cbacdafb714a9a538203def90305e73229e0f863a0453e344331ad1ef93ddc4f3cc7345a89fdc85c641a440037703b8b227767e37860668eec325ee4e96f0fa658d5ce3989c8c4e2c840254f521e2d001d3a28bef24478e699bb7946745d20c16e50445e6dcb2d9551b1a55f44f8c54e26cc9aa24a1a02752e650f748db11fb8151b5c74f1006a3cd1484b67846543c865fc9d73b8e2a4017e03ccaa0ab1eb005130dbd7a72a1fa5354915d4f10f8e85f51dd78fd0df1ff4df886510157a2f40483ef3cfde056ccea3b6239cef5707c3e4a12ab9bc46a942b2735e3696e52f70453234ef6b07e87dc995cbf925d29098e2090ab4c1e172762bc80cb6dc167607bccce2f95afd5686b57927658509c89b0ed6ab6ea91ccc32cb8cb7de9171de8ad95217e8f91a945be031dc9f1fa92eac656b690f747572fb83e844439fb9d4b6d165432f877ff1b1a13996e346a277e9216868793f118157b45317eba5bd77c10b5e4af2f0e822013bd4c42c6744dfd939ab3e034d4a8db5c6f5b3777d28e0608196b0221aed82ac351fbb4e9db1567989d82321e6d8af49344e0ed4471b4e2d49e54c176a5e5ffce49e08b3b2dbf69f8e4eb141bed81eeddb5048657d117d0295076c3e71bef367da99e23ddc7fcd501f8f16a73aad9432921783f04438c29ba8e814b935e059b87e2d8827e790a3ce4635ab25049913c124699d5ce3d13727b97873bf4899b68eb4a0cd65eeaaebf54bb53fbd546ca8be81f5c4f018301a2f75e0de35102ca61551d13bb8509f2a14c4300dc7104ebbe1ecba52d6d26fe2e70944ee9338ed2a44c508dbe3ee9f90e694186452a8e1f0db3bafedae08e8e7351ef20462b8543f5bd3a974845a7b686eff7071ea22e54b1e38092c724b0b7d8b272f5eb5e40475c30dd05dd80564d4b8898d95bfa176e019a620432529673f591230669644dbe472ced987d73c9732e2ced4671cb18b7e6457afb606daf8958b5802ac10822ec8f212eaa222a498b751ee4f7e5205b12b5d6e7d284514cc627a29a110e5b7984d0f926d3c44d35fdb26d13d59ae3ea94a40854ade31a6bc85cecc8d561942f26818cecfbd63809f3fa9af90930966fecdc864a429dc137b7d8d362873b401e95c54982890f16f96f1833822ab14c543c350d782e03cf91692b85c78246929df628585e56229d3d6405377e4552e2add2fdc2d6390d6b7e66ddded6b3d9f02ff6527bf88c710cc0d254d888d466771202479bcf29a898440d7fb09f6b5aa2a63c5a8f688c3f55acfbec560a3a2de6b55e8263a938a30fdfb4787630e6d16fc958455319cd70069eeb9b0abb5a7f6f177d6242c3cd4bd4487d2591d43c162d2b016a1d5405b7c82f154e0983d023256047148acf64b0dde0c5be94887211d9eb398cc20f2416eaff7296a065c9a1aacaf97a42d4c4bfa441d216d7a7758e532f5c82085953b143e6b68ae2f9356a978f310f1ebc21e81b2b3b413e4fc29b02ca42d705005085ae3091b28e9bee325c85e569b96e5aebaff41c45301d02cd542808cfc360453e34c780695e8afcb1e341c12ee3bfd4cb1f8069a94ca34962eb2aa277a0f5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f9d8235ae34d6bcbb22a808c55ba055f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
